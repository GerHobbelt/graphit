This is the guide for evaluating our CGO 2020 paper, **PriorityGraph:A Unified Programming Model for Optimizing Ordered Graph Algorithms**. The following guide consists of a step by step instruction to reproduce Figure 9 (generating C++ code for Single Source Shortest Paths with Delta Steppng using different schedules) and Table 4 (PriorityGraph's Perfromance on our 2-socket machine).  The schedules we used here are very likely  **NOT** the fastest schedules for your machine. **Please only use the instructions here as examples for writing and compiling different schedules, and tune schedules to best fit your machine's features.**


## Setup PriorityGraph 
PriorityGraph is implemented as an extension to GraphIt for supporting ordered parallelism as stated in the paper. You do **NOT** need any additional setup instruction other than setting up GraphIt. 

**Please first follow the [Getting Started Guide](https://github.com/GraphIt-DSL/graphit/blob/master/README.md ) to set up GraphIt.** . This guide  compile and test the correctness of a series of PriorityGraph algorithms.

## Examine the algorithm source files used in the paper 
The programs used in the paper (sssp_delta_stepping.gt, pppsp_delta_stepping, astar.gt, k_core.gt, and set_cover.gt) are stored in the `graphit/apps` directory. All PriorityGraph programs are just graphit programs with priority extensions. The rest of the evaluation guide will generate programs from these PriorityGraph / GraphIt programs. 

## Reproducing SSSP with Delta Stepping with different schedules 

This script demonstrates GraphIt's ability to generate code for lazy and eager schedules, and combine them with other schedules. Figure 9 in the paper shows the different C++ code generated by applying different schedules to Single Source Shortest Paths (SSSP) with Delta Stepping. We have built a script to generate the code for Delta Stepping with different schedules shown in the paper and a few even more complicated schedules. The script also makes sure the generated C++ code compiles successfully. The script simply compiles the PriorityGraph programs. 

```
  #graphit is the root directory of the repository
  cd  graphit/graphit_eval/priority_graph_cgo2020_eval
  cd sssp_delta_stepping_example
  python compile_sssp_delta_stepping_fig9.py
```

The program should output the information on each schedule, print the generated C++ file to stdout, and save the generated file in .cpp files in the directory. The schedules we used are stored in `sssp_delta_stepping_example/schedules`. We added a eager with bucket fusion schedule that was not included in the paper due to space constraints. The code in Figure 9 (c) is wrapped inside the runtime library OrderedProcessingOperator in `graphit/src/runtime_lib/infra_gapbs/ordered_processing.h`. 

## Running PriorityGraph generated programs with a single thread on a small graph ## 

### Generating the C++ files from PriorityGraph programs

Here we provide a script that will compile (displaying the commands used) the PriorityGraph programs (with .gt extensions) in the `graphit/apps` directory, SSSP with delta stepping, PPSP, AStar Search, KCore, and SetCover into C++ programs using the schedules shown in the paper. 

```
#start from graphit root directory
cd  graphit/graphit_eval/priority_graph_cgo2020_eval/perf_eval

#compile the graphit files (.gt) into C++ files with schedules used in the paper (from  graphit/test/input_with_schedules directory)
make graphit_files

#compile the generated C++ files
make cpps
```

The generated cpp files are in the `perf_eval/cpps` directory, and the compiled binaries are in the `perf_eval/bin` directory. 

### Running PriorityGraph Programs on Small Graphs

The following commands run the **serial** version of GraphIt compiled programs (from the earlier section) on small graphs, testGraph and Monaco. Both the unweighted and weighted versions are in `graphit/graphit_eval/priority_graph_cgo2020_eval/perf_eval/graphs` directory.

```
#start from graphit root directory
cd  graphit/graphit_eval/priority_graph_cgo2020_eval/perf_eval

#run and benchmark the performance for testGraph on SSSP with delta stepping, ppsp, wBFS, kcore, and setcover 
python table4_priority_graph.py

#run astar on monaco (needs special data on coordinates)
python table4_priority_graph.py -a astar -g monaco
```

The script table4_priority_graph.py first runs the benchmarks and then saves the outputs to the `graphit/graphit_eval/priority_graph_cgo2020_eval/perf_eval/benchmark_logs` directory. The benchmark script choose the binary based on the graph. Then a separate script parses the outputs to generate the final table of performance in the following form. The application and graph information are shown in the leftmost column, and the running times are shown in the second column in seconds.
```
# performance results from running ds, ppsp, wBFS, kcore, and setcover on testGraph
 -------------------
frameworks: graphit 
 -------------------
ds
testGraph, 2e-06
ppsp
testGraph, 1e-06
wBFS
testGraph, 2e-06
kcore
testGraph, 2.4e-05
setcover
testGraph, 8e-05
Done parsing the run outputs

# performance results from running astar on monaco graph
 -------------------
frameworks: graphit 
 -------------------
astar
monaco, 7.6e-05
Done parsing the run output
```
These runs should complete very quickly. This test on the small graphs demonstrate that the compiler can compile and run all the PriorityGraph extensions in graphit programs. We have verified the correctness of the compiled programs in the test suite of the compiler run in [Getting Started Guide](https://github.com/GraphIt-DSL/graphit/blob/master/README.md). 

To see more options that run specific graphs and algorithms, simply type the following command. 
```
#To see options for running a specific graph or application / algorithm
python table4_priority_graph.py -h
```

## Reproducing PriorityGraph Performance on 2-socekt Intel Xeon E5-2695 v3 CPUs with 30 MB LLC, TPH enabled. ## 