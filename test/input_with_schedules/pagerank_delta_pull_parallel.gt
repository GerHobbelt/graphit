element Vertex end
element Edge end
const edges : edgeset{Edge}(Vertex,Vertex) = load (argv[1]);
const vertices : vertexset{Vertex} = edges.getVertices();
const cur_rank : vector{Vertex}(float) = 1.0/vertices.size();
const ngh_sum : vector{Vertex}(float) = 0.0;
const delta : vector{Vertex}(float) = 1.0/vertices.size();
const out_degree : vector {Vertex}(int) = edges.getOutDegrees();
const error : vector{Vertex}(float) = 0.0;
const damp : float = 0.85;
const beta_score : float = (1.0 - damp) / vertices.size();
const epsilon2 : float = 0.01;
const epsilon : float = 0.0000001;

func updateEdge(src : Vertex, dst : Vertex)
    ngh_sum[dst] += delta[src] /out_degree[src];
end

func updateVertexFirstRound(v : Vertex) -> output : bool
    delta[v] = damp*(ngh_sum[v]) + beta_score;
    cur_rank[v] += delta[v];
    delta[v] = delta[v] - 1.0/vertices.size();
    output = (fabs(delta[v]) > epsilon2*cur_rank[v]);
    ngh_sum[v] = 0;
end

func updateVertex(v : Vertex) -> output : bool
   delta[v] = ngh_sum[v]*damp;
   cur_rank[v]+= delta[v];
   output = fabs(delta[v]) > epsilon2*cur_rank[v];
   ngh_sum[v] = 0;
end

func printRank(v : Vertex)
    print cur_rank[v];
end

func main()
    startTimer();
    var n : int = edges.getVertices();
    var frontier : vertexset{Vertex} = new vertexset{Vertex}(n);

    for i in 1:10
        #s1# frontier = edges.from(frontier).apply(updateEdge).modified(ngh_sum);
        if i == 1
            frontier = frontier.where(updateVertexFirstRound);
        else
            frontier = frontier.where(updateVertex);
        end
    end

    var elapsed_time : float = stopTimer();
    var sum : float = 0;
    for i in 0:edges.getVertices()
        sum += error[i];
    end
    print sum;

    print "elapsed time: ";
    print elapsed_time;
end

schedule:
    program->setApply("s1", "pull")->setApply("s1", "parallel");
    // program->fuseFields("delta", "out_degree");