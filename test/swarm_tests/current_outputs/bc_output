#include "swarm_intrinsics.h"
#include "scc/queues.h"
#include "scc/autoparallel.h"
int __argc;
char **__argv;
swarm_runtime::GraphT<int> edges;
double *num_paths;
double *dependences;
bool *visited;
swarm::BucketQueue<int32_t> swarm_frontier;
void visited_generated_vector_op_apply_func_2(int v) {
        visited[v] = (bool)0;
}
void dependences_generated_vector_op_apply_func_1(int v) {
        dependences[v] = 0;
}
void num_paths_generated_vector_op_apply_func_0(int v) {
        num_paths[v] = 0;
}
bool forward_update(int src, int dst) {
        bool output4;
        bool num_paths_trackving_var_3 = (bool)0;
        num_paths_trackving_var_3 = swarm_runtime::sum_reduce(num_paths[dst], num_paths[src]);
        output4 = num_paths_trackving_var_3;
        return output4;
}
bool visited_vertex_filter(int v) {
        bool output;
        output = (visited[v]) == ((bool)0);
        return output;
}
void mark_visited(int v) {
        visited[v] = (bool)1;
}
void mark_unvisited(int v) {
        visited[v] = (bool)0;
}
void backward_vertex_f(int v) {
        visited[v] = (bool)1;
        swarm_runtime::sum_reduce(dependences[v], (1 / num_paths[v]));
}
void backward_update(int src, int dst) {
        swarm_runtime::sum_reduce(dependences[dst], dependences[src]);
}
void final_vertex_f(int v) {
        dependences[v] = ((dependences[v] - (1 / num_paths[v])) * num_paths[v]);
}
SWARM_FUNC_ATTRIBUTES
void swarm_main() {
        swarm_runtime::GraphT<char> transposed_edges = swarm_runtime::builtin_transpose(edges);
        swarm_runtime::VertexFrontier frontier = swarm_runtime::create_new_vertex_set(swarm_runtime::builtin_getVertices(edges), 0);
        swarm_runtime::builtin_addVertex(frontier, 8);
        num_paths[8] = 1;
        visited[8] = (bool)1;
        int round = 0;
        swarm_runtime::VertexFrontierList frontier_list = swarm_runtime::create_new_vertex_frontier_list(swarm_runtime::builtin_getVertices(edges));
        swarm_runtime::builtin_insert(frontier_list, frontier);
        swarm_runtime::populate_swarm_frontier(frontier, swarm_frontier);
        swarm_frontier.for_each_prio([&round](unsigned level, std::pair<int, int> src_pair, auto push) {
                switch (level % 4) {
                case 0: {
                        push(level + 1, std::make_pair<int, int>(std::get<0>(src_pair), std::get<1>(src_pair)));
                        break;
                }
                case 1: {
                        int32_t edgeZero = edges.h_src_offsets[std::get<0>(src_pair)];
                        int32_t edgeLast = edges.h_src_offsets[std::get<0>(src_pair)+1];
                        for (int i = edgeZero; i < edgeLast; i++) {
                                int dst = edges.h_edge_dst[i];
                                int src = std::get<0>(src_pair);
                                {
                                        bool num_paths_trackving_var_3 = (bool)0;
                                        num_paths_trackving_var_3 = swarm_runtime::sum_reduce(num_paths[dst], num_paths[src]);
                                        output4 = num_paths_trackving_var_3;
                                        if (output4) {
                                                push(level + 1, std::make_pair<int, int>(dst, std::get<1>(src_pair)));
                                        }
                                }
                        }
                        break;
                }
                case 2: {
                        mark_visited(std::get<0>(src_pair));
;
                        push(level + 1, std::make_pair<int, int>(std::get<0>(src_pair), std::get<1>(src_pair)));
                        break;
                }
                case 3: {
                        swarm_runtime::builtin_insert(frontier_list, src);
                        push(level + 1, std::make_pair<int, int>(std::get<0>(src_pair), std::get<1>(src_pair)+ 1));
                        break;
                }
                }
        }, [&round](unsigned level) {
                switch (level % 4) {
                case 0: {
                        round = (round + 1);
                        break;
                }
                case 1: {
                        break;
                }
                case 2: {
                        break;
                }
                case 3: {
                        break;
                }
                }
        });
        swarm_runtime::clear_frontier(frontier);
        for (int _iter = 0; _iter < swarm_runtime::builtin_getVertices(edges); _iter++) {
                mark_unvisited(_iter);
        };
        swarm_runtime::builtin_retrieve(frontier_list, frontier);
        swarm_runtime::builtin_retrieve(frontier_list, frontier);
        int frontier_size = frontier.size();
        for (int i = 0; i < frontier_size; i++) {
                int32_t current = frontier[i];
                backward_vertex_f(current);
        };
        round = (round - 1);
        while ((round) > (0)) {
                int frontier_size = frontier.size();
                for (int i = 0; i < frontier_size; i++) {
                        int32_t current = frontier[i];
                        int32_t edgeZero = transposed_edges.h_src_offsets[current];
                        int32_t edgeLast = transposed_edges.h_src_offsets[current+1];
                        for (int j = edgeZero; j < edgeLast; j++) {
                                int ngh = transposed_edges.h_edge_dst[j];
                                if (visited_vertex_filter(ngh)) {
                                        backward_update(current, ngh);
                                }
                        }
                };
                swarm_runtime::builtin_retrieve(frontier_list, frontier);
                int frontier_size = frontier.size();
                for (int i = 0; i < frontier_size; i++) {
                        int32_t current = frontier[i];
                        backward_vertex_f(current);
                };
                round = (round - 1);
        }
        deleteObject(frontier);
        for (int _iter = 0; _iter < swarm_runtime::builtin_getVertices(edges); _iter++) {
                final_vertex_f(_iter);
        };
}
int main(int argc, char* argv[]) {
        __argc = argc;
        __argv = argv;
        swarm_runtime::load_graph(edges, "../test/graphs/4.el");
        num_paths = new double[swarm_runtime::builtin_getVertices(edges)];
        dependences = new double[swarm_runtime::builtin_getVertices(edges)];
        visited = new bool[swarm_runtime::builtin_getVertices(edges)];
        for (int _iter = 0; _iter < swarm_runtime::builtin_getVertices(edges); _iter++) {
                num_paths_generated_vector_op_apply_func_0(_iter);
        };
        for (int _iter = 0; _iter < swarm_runtime::builtin_getVertices(edges); _iter++) {
                dependences_generated_vector_op_apply_func_1(_iter);
        };
        for (int _iter = 0; _iter < swarm_runtime::builtin_getVertices(edges); _iter++) {
                visited_generated_vector_op_apply_func_2(_iter);
        };
                SCC_PARALLEL( swarm_main(); );
}