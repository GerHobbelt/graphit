#include "swarm_intrinsics.h"
#include "scc/queues.h"
#include "scc/autoparallel.h"
int __argc;
char **__argv;
swarm_runtime::GraphT<int> edges;
int *IDs;
swarm::PrioQueue<int32_t> swarm_frontier;
void IDs_generated_vector_op_apply_func_0(int v) {
        IDs[v] = 1;
}
bool updateEdge(int src, int dst) {
        bool output2;
        bool IDs_trackving_var_1 = (bool)0;
        IDs_trackving_var_1 = swarm_runtime::min_reduce(IDs[dst], IDs[src]);
        output2 = IDs_trackving_var_1;
        return output2;
}
void init(int v) {
        IDs[v] = v;
}
void printID(int v) {
        swarm_runtime::print(IDs[v]);
}
SWARM_FUNC_ATTRIBUTES
void swarm_main() {
        int n = swarm_runtime::builtin_getVertices(edges);
        swarm_runtime::VertexFrontier frontier = swarm_runtime::create_new_vertex_set(swarm_runtime::builtin_getVertices(edges), n);
        for (int _iter = 0; _iter < swarm_runtime::builtin_getVertices(edges); _iter++) {
                init(_iter);
        };
        swarm_runtime::populate_swarm_frontier(frontier, swarm_frontier);
        swarm_frontier.for_each_prio([](unsigned level, int src, auto push) {
                int32_t edgeZero = edges.h_src_offsets[src];
                int32_t edgeLast = edges.h_src_offsets[src+1];
                for (int i = edgeZero; i < edgeLast; i++) {
                        int dst = edges.h_edge_dst[i];
                        int src = src;
                        {
                                bool IDs_trackving_var_1 = (bool)0;
                                IDs_trackving_var_1 = swarm_runtime::min_reduce(IDs[dst], IDs[src]);
                                output2 = IDs_trackving_var_1;
                                if (output2) {
                                        push(level + 1, dst);
                                }
                        }
                }
        });
        swarm_runtime::clear_frontier(frontier);
        for (int _iter = 0; _iter < swarm_runtime::builtin_getVertices(edges); _iter++) {
                printID(_iter);
        };
}
int main(int argc, char* argv[]) {
        __argc = argc;
        __argv = argv;
        swarm_runtime::load_graph(edges, "../test/graphs/4.el");
        IDs = new int[swarm_runtime::builtin_getVertices(edges)];
        for (int _iter = 0; _iter < swarm_runtime::builtin_getVertices(edges); _iter++) {
                IDs_generated_vector_op_apply_func_0(_iter);
        };
                SCC_PARALLEL( swarm_main(); );
}